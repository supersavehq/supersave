import type { NextApiRequest, NextApiResponse } from "next";
import Http from "./collection/http";
import type Manager from "./collection/manager";
import type { Router } from "better-call"; // Assuming better-call exports a Router type

/**
 * Creates a Next.js API route handler for SuperSave.
 *
 * @param manager - The SuperSave Manager instance containing the collections.
 * @param prefix - Optional URL prefix for all SuperSave routes (e.g., '/api/supersave').
 *                 This prefix is used by SuperSave to generate internal links correctly.
 *                 The Next.js file system routing will determine the actual base path.
 *                 For example, if your file is `pages/api/supersave/[...slug].ts`,
 *                 and you want SuperSave routes like `/api/supersave/users`,
 *                 the prefix passed here should match that part, e.g., '/api/supersave'.
 * @returns A Promise that resolves to a Next.js API route handler function.
 */
export async function createNextApiHandler(
  manager: Manager,
  prefix: string = "/",
): Promise<(req: NextApiRequest, res: NextApiResponse) => Promise<void>> {
  try {
    // Ensure prefix starts with a slash and doesn't end with one for consistency if it's not just "/"
    let consistentPrefix = prefix;
    if (!consistentPrefix.startsWith("/")) {
      consistentPrefix = `/${consistentPrefix}`;
    }
    if (consistentPrefix.endsWith("/") && consistentPrefix.length > 1) {
      consistentPrefix = consistentPrefix.slice(0, -1);
    }

    const httpInstance = await Http.create(manager, consistentPrefix);
    const router = httpInstance.getRouter() as Router; // Get the better-call router

    // Return an async function compatible with Next.js API routes
    return async (req: NextApiRequest, res: NextApiResponse): Promise<void> => {
      // If the router from better-call is Express-like, it can be called as a handler.
      // We might need to handle the case where `router` doesn't automatically end the response
      // or if it calls a `next` function that doesn't exist in this context.
      // For now, assume it handles req/res directly or calls methods on `res` to end it.

      // We need to potentially adjust req.url if Next.js file routing creates a base path.
      // For example, if the file is /pages/api/store/[...parts].js, and req.url is /api/store/users,
      // the router might expect /users if the prefix was passed as /api/store.
      // However, Http.create already takes the full prefix.
      // The router generated by Http.create will have routes like /prefix/collectionName.
      // So, req.url as provided by Next.js should be fine.

      // A common pattern for using an Express-style router in a serverless function
      // is to promisify its execution or ensure it handles ending the response.
      // If `better-call`'s router doesn't automatically call `res.end()` or similar,
      // we might need to listen for events or use a helper.
      // For now, let's assume a simple invocation works.
      try {
        // better-call router is Express-like, so it should be callable.
        // It might expect a `next` callback for errors.
        await new Promise<void>((resolve, reject) => {
          const nextCallback = (err?: any) => {
            if (err) {
              // If an error occurs in the router, propagate it.
              // This could be a generic error or a SuperSave HookError
              console.error("Error in SuperSave Next.js handler:", err);
              // Ensure some response is sent for unhandled errors from the router
              if (!res.writableEnded) {
                res.status(500).json({
                  message: "Internal server error from SuperSave handler",
                });
              }
              reject(err); // Reject the promise
            } else {
              // If the router finishes without error but doesn't send a response,
              // this could be an issue. However, typical HTTP routers would.
              // If not, Next.js will warn about API route not sending a response.
              if (!res.writableEnded) {
                // This case should ideally be handled by the router itself (e.g. 404)
                res
                  .status(404)
                  .json({ message: "Not found by SuperSave handler" });
              }
              resolve(); // Resolve the promise
            }
          };

          // @ts-expect-error: Express/connect middleware signature
          router(req, res, nextCallback);
        });
      } catch (error) {
        // This catch is for errors during the router execution promise (e.g. from nextCallback(err))
        // Or if router() itself throws synchronously, though less common for I/O routers.
        if (!res.writableEnded) {
          // Check if it's a known error type, e.g., HookError
          // For now, generic error.
          res.status(500).json({
            message: "An error occurred processing the request in SuperSave.",
            error: error instanceof Error ? error.message : String(error),
          });
        }
        // Ensure the outer promise of the handler also reflects this failure if needed,
        // though Next.js primarily cares about the response being sent.
      }
    };
  } catch (error) {
    console.error("Failed to create SuperSave Next.js API handler:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    // Return a handler that consistently reports the setup failure
    return async (req: NextApiRequest, res: NextApiResponse): Promise<void> => {
      res.status(500).json({
        message: "SuperSave handler initialization failed.",
        error: errorMessage,
      });
    };
  }
}
